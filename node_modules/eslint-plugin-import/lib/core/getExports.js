'use strict';

exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.recursivePatternCapture = recursivePatternCapture;

require('es6-symbol/implement');

var _es6Map = require('es6-map');

var _es6Map2 = _interopRequireDefault(_es6Map);

var _fs = require('fs');

var fs = _interopRequireWildcard(_fs);

var _crypto = require('crypto');

var _doctrine = require('doctrine');

var doctrine = _interopRequireWildcard(_doctrine);

var _parse2 = require('./parse');

var _parse3 = _interopRequireDefault(_parse2);

var _resolve = require('./resolve');

var _resolve2 = _interopRequireDefault(_resolve);

var _ignore = require('./ignore');

var _ignore2 = _interopRequireDefault(_ignore);

var _hash = require('./hash');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var exportCache = new _es6Map2.default();

/**
 * detect exports without a full parse.
 * used primarily to ignore the import/ignore setting, iif it looks like
 * there might be something there (i.e., jsnext:main is set).
 * @type {RegExp}
 */
var hasExports = new RegExp('(^|[\\n;])\\s*export\\s[\\w{*]');

var ExportMap = function () {
  function ExportMap(path) {
    _classCallCheck(this, ExportMap);

    this.path = path;
    this.namespace = new _es6Map2.default();
    // todo: restructure to key on path, value is resolver + map of names
    this.reexports = new _es6Map2.default();
    this.dependencies = new _es6Map2.default();
    this.errors = [];
  }

  ExportMap.get = function get(source, context) {

    var path = (0, _resolve2.default)(source, context);
    if (path == null) return null;

    return ExportMap.for(path, context);
  };

  ExportMap.for = function _for(path, context) {
    var exportMap = void 0;

    var cacheKey = (0, _hash.hashObject)((0, _crypto.createHash)('sha256'), {
      settings: context.settings,
      parserPath: context.parserPath,
      parserOptions: context.parserOptions,
      path: path
    }).digest('hex');

    exportMap = exportCache.get(cacheKey);

    // return cached ignore
    if (exportMap === null) return null;

    var stats = fs.statSync(path);
    if (exportMap != null) {
      // date equality check
      if (exportMap.mtime - stats.mtime === 0) {
        return exportMap;
      }
      // future: check content equality?
    }

    var content = fs.readFileSync(path, { encoding: 'utf8' });

    // check for and cache ignore
    if ((0, _ignore2.default)(path, context) && !hasExports.test(content)) {
      exportCache.set(cacheKey, null);
      return null;
    }

    exportMap = ExportMap.parse(path, content, context);
    exportMap.mtime = stats.mtime;

    exportCache.set(cacheKey, exportMap);
    return exportMap;
  };

  ExportMap.parse = function parse(path, content, context) {
    var m = new ExportMap(path);

    try {
      var ast = (0, _parse3.default)(content, context);
    } catch (err) {
      m.errors.push(err);
      return m; // can't continue
    }

    var docstyle = context.settings && context.settings['import/docstyle'] || ['jsdoc'];
    var docStyleParsers = {};
    docstyle.forEach(function (style) {
      docStyleParsers[style] = availableDocStyleParsers[style];
    });

    // attempt to collect module doc
    ast.comments.some(function (c) {
      if (c.type !== 'Block') return false;
      try {
        var doc = doctrine.parse(c.value, { unwrap: true });
        if (doc.tags.some(function (t) {
          return t.title === 'module';
        })) {
          m.doc = doc;
          return true;
        }
      } catch (err) {/* ignore */}
      return false;
    });

    var namespaces = new _es6Map2.default();

    function remotePath(node) {
      return _resolve2.default.relative(node.source.value, path, context.settings);
    }

    function resolveImport(node) {
      var rp = remotePath(node);
      if (rp == null) return null;
      return ExportMap.for(rp, context);
    }

    function getNamespace(identifier) {
      if (!namespaces.has(identifier.name)) return;

      return function () {
        return resolveImport(namespaces.get(identifier.name));
      };
    }

    function addNamespace(object, identifier) {
      var nsfn = getNamespace(identifier);
      if (nsfn) {
        Object.defineProperty(object, 'namespace', { get: nsfn });
      }

      return object;
    }

    ast.body.forEach(function (n) {

      if (n.type === 'ExportDefaultDeclaration') {
        var exportMeta = captureDoc(docStyleParsers, n);
        if (n.declaration.type === 'Identifier') {
          addNamespace(exportMeta, n.declaration);
        }
        m.namespace.set('default', exportMeta);
        return;
      }

      if (n.type === 'ExportAllDeclaration') {
        var _ret = function () {
          var remoteMap = remotePath(n);
          if (remoteMap == null) return {
              v: void 0
            };
          m.dependencies.set(remoteMap, function () {
            return ExportMap.for(remoteMap, context);
          });
          return {
            v: void 0
          };
        }();

        if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
      }

      // capture namespaces in case of later export
      if (n.type === 'ImportDeclaration') {
        var ns = void 0;
        if (n.specifiers.some(function (s) {
          return s.type === 'ImportNamespaceSpecifier' && (ns = s);
        })) {
          namespaces.set(ns.local.name, n);
        }
        return;
      }

      if (n.type === 'ExportNamedDeclaration') {
        // capture declaration
        if (n.declaration != null) {
          switch (n.declaration.type) {
            case 'FunctionDeclaration':
            case 'ClassDeclaration':
            case 'TypeAlias':
              // flowtype with babel-eslint parser
              m.namespace.set(n.declaration.id.name, captureDoc(docStyleParsers, n));
              break;
            case 'VariableDeclaration':
              n.declaration.declarations.forEach(function (d) {
                return recursivePatternCapture(d.id, function (id) {
                  return m.namespace.set(id.name, captureDoc(docStyleParsers, d, n));
                });
              });
              break;
          }
        }

        n.specifiers.forEach(function (s) {
          var exportMeta = {};
          var local = void 0;

          switch (s.type) {
            case 'ExportDefaultSpecifier':
              if (!n.source) return;
              local = 'default';
              break;
            case 'ExportNamespaceSpecifier':
              m.namespace.set(s.exported.name, Object.defineProperty(exportMeta, 'namespace', {
                get: function get() {
                  return resolveImport(n);
                }
              }));
              return;
            case 'ExportSpecifier':
              if (!n.source) {
                m.namespace.set(s.exported.name, addNamespace(exportMeta, s.local));
                return;
              }
            // else falls through
            default:
              local = s.local.name;
              break;
          }

          // todo: JSDoc
          m.reexports.set(s.exported.name, { local: local, getImport: function getImport() {
              return resolveImport(n);
            } });
        });
      }
    });

    return m;
  };

  /**
   * Note that this does not check explicitly re-exported names for existence
   * in the base namespace, but it will expand all `export * from '...'` exports
   * if not found in the explicit namespace.
   * @param  {string}  name
   * @return {Boolean} true if `name` is exported by this module.
   */


  ExportMap.prototype.has = function has(name) {
    if (this.namespace.has(name)) return true;
    if (this.reexports.has(name)) return true;

    // default exports must be explicitly re-exported (#328)
    if (name !== 'default') {
      for (var _iterator = this.dependencies.values(), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref;

        if (_isArray) {
          if (_i >= _iterator.length) break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done) break;
          _ref = _i.value;
        }

        var dep = _ref;

        var innerMap = dep();

        // todo: report as unresolved?
        if (!innerMap) continue;

        if (innerMap.has(name)) return true;
      }
    }

    return false;
  };

  /**
   * ensure that imported name fully resolves.
   * @param  {[type]}  name [description]
   * @return {Boolean}      [description]
   */


  ExportMap.prototype.hasDeep = function hasDeep(name) {
    if (this.namespace.has(name)) return { found: true, path: [this] };

    if (this.reexports.has(name)) {
      var _reexports$get = this.reexports.get(name);

      var local = _reexports$get.local;
      var getImport = _reexports$get.getImport;
      var imported = getImport();

      // if import is ignored, return explicit 'null'
      if (imported == null) return { found: true, path: [this] };

      // safeguard against cycles, only if name matches
      if (imported.path === this.path && local === name) return { found: false, path: [this] };

      var deep = imported.hasDeep(local);
      deep.path.unshift(this);

      return deep;
    }

    // default exports must be explicitly re-exported (#328)
    if (name !== 'default') {
      for (var _iterator2 = this.dependencies.values(), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
        var _ref2;

        if (_isArray2) {
          if (_i2 >= _iterator2.length) break;
          _ref2 = _iterator2[_i2++];
        } else {
          _i2 = _iterator2.next();
          if (_i2.done) break;
          _ref2 = _i2.value;
        }

        var dep = _ref2;

        var innerMap = dep();
        // todo: report as unresolved?
        if (!innerMap) continue;

        // safeguard against cycles
        if (innerMap.path === this.path) continue;

        var innerValue = innerMap.hasDeep(name);
        if (innerValue.found) {
          innerValue.path.unshift(this);
          return innerValue;
        }
      }
    }

    return { found: false, path: [this] };
  };

  ExportMap.prototype.get = function get(name) {
    if (this.namespace.has(name)) return this.namespace.get(name);

    if (this.reexports.has(name)) {
      var _reexports$get2 = this.reexports.get(name);

      var local = _reexports$get2.local;
      var getImport = _reexports$get2.getImport;
      var imported = getImport();

      // if import is ignored, return explicit 'null'
      if (imported == null) return null;

      // safeguard against cycles, only if name matches
      if (imported.path === this.path && local === name) return undefined;

      return imported.get(local);
    }

    // default exports must be explicitly re-exported (#328)
    if (name !== 'default') {
      for (var _iterator3 = this.dependencies.values(), _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
        var _ref3;

        if (_isArray3) {
          if (_i3 >= _iterator3.length) break;
          _ref3 = _iterator3[_i3++];
        } else {
          _i3 = _iterator3.next();
          if (_i3.done) break;
          _ref3 = _i3.value;
        }

        var dep = _ref3;

        var innerMap = dep();
        // todo: report as unresolved?
        if (!innerMap) continue;

        // safeguard against cycles
        if (innerMap.path === this.path) continue;

        var innerValue = innerMap.get(name);
        if (innerValue !== undefined) return innerValue;
      }
    }

    return undefined;
  };

  ExportMap.prototype.forEach = function forEach(callback, thisArg) {
    var _this = this;

    this.namespace.forEach(function (v, n) {
      return callback.call(thisArg, v, n, _this);
    });

    this.reexports.forEach(function (_ref4, name) {
      var getImport = _ref4.getImport;
      var local = _ref4.local;

      var reexported = getImport();
      // can't look up meta for ignored re-exports (#348)
      callback.call(thisArg, reexported && reexported.get(local), name, _this);
    });

    this.dependencies.forEach(function (dep) {
      return dep().forEach(function (v, n) {
        return n !== 'default' && callback.call(thisArg, v, n, _this);
      });
    });
  };

  // todo: keys, values, entries?

  ExportMap.prototype.reportErrors = function reportErrors(context, declaration) {
    context.report({
      node: declaration.source,
      message: 'Parse errors in imported module \'' + declaration.source.value + '\': ' + ('' + this.errors.map(function (e) {
        return e.message + ' (' + e.lineNumber + ':' + e.column + ')';
      }).join(', '))
    });
  };

  _createClass(ExportMap, [{
    key: 'hasDefault',
    get: function get() {
      return this.get('default') != null;
    } // stronger than this.has

  }, {
    key: 'size',
    get: function get() {
      var size = this.namespace.size + this.reexports.size;
      this.dependencies.forEach(function (dep) {
        return size += dep().size;
      });
      return size;
    }
  }]);

  return ExportMap;
}();

/**
 * parse docs from the first node that has leading comments
 * @param  {...[type]} nodes [description]
 * @return {{doc: object}}
 */


exports.default = ExportMap;
function captureDoc(docStyleParsers) {
  var metadata = {};

  // 'some' short-circuits on first 'true'

  for (var _len = arguments.length, nodes = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    nodes[_key - 1] = arguments[_key];
  }

  nodes.some(function (n) {
    if (!n.leadingComments) return false;

    for (var name in docStyleParsers) {
      var doc = docStyleParsers[name](n.leadingComments);
      if (doc) {
        metadata.doc = doc;
      }
    }

    return true;
  });

  return metadata;
}

var availableDocStyleParsers = {
  jsdoc: captureJsDoc,
  tomdoc: captureTomDoc
};

/**
 * parse JSDoc from leading comments
 * @param  {...[type]} comments [description]
 * @return {{doc: object}}
 */
function captureJsDoc(comments) {
  var doc = void 0;

  // capture XSDoc
  comments.forEach(function (comment) {
    // skip non-block comments
    if (comment.value.slice(0, 4) !== '*\n *') return;
    try {
      doc = doctrine.parse(comment.value, { unwrap: true });
    } catch (err) {
      /* don't care, for now? maybe add to `errors?` */
    }
  });

  return doc;
}

/**
  * parse TomDoc section from comments
  */
function captureTomDoc(comments) {
  // collect lines up to first paragraph break
  var lines = [];
  for (var i = 0; i < comments.length; i++) {
    var comment = comments[i];
    if (comment.value.match(/^\s*$/)) break;
    lines.push(comment.value.trim());
  }

  // return doctrine-like object
  var statusMatch = lines.join(' ').match(/^(Public|Internal|Deprecated):\s*(.+)/);
  if (statusMatch) {
    return {
      description: statusMatch[2],
      tags: [{
        title: statusMatch[1].toLowerCase(),
        description: statusMatch[2]
      }]
    };
  }
}

/**
 * Traverse a pattern/identifier node, calling 'callback'
 * for each leaf identifier.
 * @param  {node}   pattern
 * @param  {Function} callback
 * @return {void}
 */
function recursivePatternCapture(pattern, callback) {
  switch (pattern.type) {
    case 'Identifier':
      // base case
      callback(pattern);
      break;

    case 'ObjectPattern':
      pattern.properties.forEach(function (_ref5) {
        var value = _ref5.value;

        recursivePatternCapture(value, callback);
      });
      break;

    case 'ArrayPattern':
      pattern.elements.forEach(function (element) {
        if (element == null) return;
        recursivePatternCapture(element, callback);
      });
      break;
  }
}
//# sourceMappingURL=data:application/json;base64,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bkIsQ0FBMkIsaUJBQWU7WUFBWixvQkFBWTs7QUFDeEMsZ0NBQXdCLEtBQXhCLEVBQStCLFFBQS9CLEVBRHdDO09BQWYsQ0FBM0IsQ0FERjtBQUlFLFlBSkY7O0FBTEYsU0FXTyxjQUFMO0FBQ0UsY0FBUSxRQUFSLENBQWlCLE9BQWpCLENBQXlCLFVBQUMsT0FBRCxFQUFhO0FBQ3BDLFlBQUksV0FBVyxJQUFYLEVBQWlCLE9BQXJCO0FBQ0EsZ0NBQXdCLE9BQXhCLEVBQWlDLFFBQWpDLEVBRm9DO09BQWIsQ0FBekIsQ0FERjtBQUtFLFlBTEY7QUFYRixHQUR5RDtDQUFwRCIsImZpbGUiOiJjb3JlL2dldEV4cG9ydHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJ2VzNi1zeW1ib2wvaW1wbGVtZW50J1xuaW1wb3J0IE1hcCBmcm9tICdlczYtbWFwJ1xuXG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcydcblxuaW1wb3J0IHsgY3JlYXRlSGFzaCB9IGZyb20gJ2NyeXB0bydcbmltcG9ydCAqIGFzIGRvY3RyaW5lIGZyb20gJ2RvY3RyaW5lJ1xuXG5pbXBvcnQgcGFyc2UgZnJvbSAnLi9wYXJzZSdcbmltcG9ydCByZXNvbHZlIGZyb20gJy4vcmVzb2x2ZSdcbmltcG9ydCBpc0lnbm9yZWQgZnJvbSAnLi9pZ25vcmUnXG5cbmltcG9ydCB7IGhhc2hPYmplY3QgfSBmcm9tICcuL2hhc2gnXG5cbmNvbnN0IGV4cG9ydENhY2hlID0gbmV3IE1hcCgpXG5cbi8qKlxuICogZGV0ZWN0IGV4cG9ydHMgd2l0aG91dCBhIGZ1bGwgcGFyc2UuXG4gKiB1c2VkIHByaW1hcmlseSB0byBpZ25vcmUgdGhlIGltcG9ydC9pZ25vcmUgc2V0dGluZywgaWlmIGl0IGxvb2tzIGxpa2VcbiAqIHRoZXJlIG1pZ2h0IGJlIHNvbWV0aGluZyB0aGVyZSAoaS5lLiwganNuZXh0Om1haW4gaXMgc2V0KS5cbiAqIEB0eXBlIHtSZWdFeHB9XG4gKi9cbmNvbnN0IGhhc0V4cG9ydHMgPSBuZXcgUmVnRXhwKCcoXnxbXFxcXG47XSlcXFxccypleHBvcnRcXFxcc1tcXFxcd3sqXScpXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEV4cG9ydE1hcCB7XG4gIGNvbnN0cnVjdG9yKHBhdGgpIHtcbiAgICB0aGlzLnBhdGggPSBwYXRoXG4gICAgdGhpcy5uYW1lc3BhY2UgPSBuZXcgTWFwKClcbiAgICAvLyB0b2RvOiByZXN0cnVjdHVyZSB0byBrZXkgb24gcGF0aCwgdmFsdWUgaXMgcmVzb2x2ZXIgKyBtYXAgb2YgbmFtZXNcbiAgICB0aGlzLnJlZXhwb3J0cyA9IG5ldyBNYXAoKVxuICAgIHRoaXMuZGVwZW5kZW5jaWVzID0gbmV3IE1hcCgpXG4gICAgdGhpcy5lcnJvcnMgPSBbXVxuICB9XG5cbiAgZ2V0IGhhc0RlZmF1bHQoKSB7IHJldHVybiB0aGlzLmdldCgnZGVmYXVsdCcpICE9IG51bGwgfSAvLyBzdHJvbmdlciB0aGFuIHRoaXMuaGFzXG5cbiAgZ2V0IHNpemUoKSB7XG4gICAgbGV0IHNpemUgPSB0aGlzLm5hbWVzcGFjZS5zaXplICsgdGhpcy5yZWV4cG9ydHMuc2l6ZVxuICAgIHRoaXMuZGVwZW5kZW5jaWVzLmZvckVhY2goZGVwID0+IHNpemUgKz0gZGVwKCkuc2l6ZSlcbiAgICByZXR1cm4gc2l6ZVxuICB9XG5cbiAgc3RhdGljIGdldChzb3VyY2UsIGNvbnRleHQpIHtcblxuICAgIHZhciBwYXRoID0gcmVzb2x2ZShzb3VyY2UsIGNvbnRleHQpXG4gICAgaWYgKHBhdGggPT0gbnVsbCkgcmV0dXJuIG51bGxcblxuICAgIHJldHVybiBFeHBvcnRNYXAuZm9yKHBhdGgsIGNvbnRleHQpXG4gIH1cblxuICBzdGF0aWMgZm9yKHBhdGgsIGNvbnRleHQpIHtcbiAgICBsZXQgZXhwb3J0TWFwXG5cbiAgICBjb25zdCBjYWNoZUtleSA9IGhhc2hPYmplY3QoY3JlYXRlSGFzaCgnc2hhMjU2JyksIHtcbiAgICAgIHNldHRpbmdzOiBjb250ZXh0LnNldHRpbmdzLFxuICAgICAgcGFyc2VyUGF0aDogY29udGV4dC5wYXJzZXJQYXRoLFxuICAgICAgcGFyc2VyT3B0aW9uczogY29udGV4dC5wYXJzZXJPcHRpb25zLFxuICAgICAgcGF0aCxcbiAgICB9KS5kaWdlc3QoJ2hleCcpXG5cbiAgICBleHBvcnRNYXAgPSBleHBvcnRDYWNoZS5nZXQoY2FjaGVLZXkpXG5cbiAgICAvLyByZXR1cm4gY2FjaGVkIGlnbm9yZVxuICAgIGlmIChleHBvcnRNYXAgPT09IG51bGwpIHJldHVybiBudWxsXG5cbiAgICBjb25zdCBzdGF0cyA9IGZzLnN0YXRTeW5jKHBhdGgpXG4gICAgaWYgKGV4cG9ydE1hcCAhPSBudWxsKSB7XG4gICAgICAvLyBkYXRlIGVxdWFsaXR5IGNoZWNrXG4gICAgICBpZiAoZXhwb3J0TWFwLm10aW1lIC0gc3RhdHMubXRpbWUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydE1hcFxuICAgICAgfVxuICAgICAgLy8gZnV0dXJlOiBjaGVjayBjb250ZW50IGVxdWFsaXR5P1xuICAgIH1cblxuICAgIGNvbnN0IGNvbnRlbnQgPSBmcy5yZWFkRmlsZVN5bmMocGF0aCwgeyBlbmNvZGluZzogJ3V0ZjgnIH0pXG5cbiAgICAvLyBjaGVjayBmb3IgYW5kIGNhY2hlIGlnbm9yZVxuICAgIGlmIChpc0lnbm9yZWQocGF0aCwgY29udGV4dCkgJiYgIWhhc0V4cG9ydHMudGVzdChjb250ZW50KSkge1xuICAgICAgZXhwb3J0Q2FjaGUuc2V0KGNhY2hlS2V5LCBudWxsKVxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICBleHBvcnRNYXAgPSBFeHBvcnRNYXAucGFyc2UocGF0aCwgY29udGVudCwgY29udGV4dClcbiAgICBleHBvcnRNYXAubXRpbWUgPSBzdGF0cy5tdGltZVxuXG4gICAgZXhwb3J0Q2FjaGUuc2V0KGNhY2hlS2V5LCBleHBvcnRNYXApXG4gICAgcmV0dXJuIGV4cG9ydE1hcFxuICB9XG5cbiAgc3RhdGljIHBhcnNlKHBhdGgsIGNvbnRlbnQsIGNvbnRleHQpIHtcbiAgICB2YXIgbSA9IG5ldyBFeHBvcnRNYXAocGF0aClcblxuICAgIHRyeSB7XG4gICAgICB2YXIgYXN0ID0gcGFyc2UoY29udGVudCwgY29udGV4dClcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIG0uZXJyb3JzLnB1c2goZXJyKVxuICAgICAgcmV0dXJuIG0gLy8gY2FuJ3QgY29udGludWVcbiAgICB9XG5cbiAgICBjb25zdCBkb2NzdHlsZSA9IChjb250ZXh0LnNldHRpbmdzICYmIGNvbnRleHQuc2V0dGluZ3NbJ2ltcG9ydC9kb2NzdHlsZSddKSB8fCBbJ2pzZG9jJ11cbiAgICBjb25zdCBkb2NTdHlsZVBhcnNlcnMgPSB7fVxuICAgIGRvY3N0eWxlLmZvckVhY2goc3R5bGUgPT4ge1xuICAgICAgZG9jU3R5bGVQYXJzZXJzW3N0eWxlXSA9IGF2YWlsYWJsZURvY1N0eWxlUGFyc2Vyc1tzdHlsZV1cbiAgICB9KVxuXG4gICAgLy8gYXR0ZW1wdCB0byBjb2xsZWN0IG1vZHVsZSBkb2NcbiAgICBhc3QuY29tbWVudHMuc29tZShjID0+IHtcbiAgICAgIGlmIChjLnR5cGUgIT09ICdCbG9jaycpIHJldHVybiBmYWxzZVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZG9jID0gZG9jdHJpbmUucGFyc2UoYy52YWx1ZSwgeyB1bndyYXA6IHRydWUgfSlcbiAgICAgICAgaWYgKGRvYy50YWdzLnNvbWUodCA9PiB0LnRpdGxlID09PSAnbW9kdWxlJykpIHtcbiAgICAgICAgICBtLmRvYyA9IGRvY1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikgeyAvKiBpZ25vcmUgKi8gfVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSlcblxuICAgIGNvbnN0IG5hbWVzcGFjZXMgPSBuZXcgTWFwKClcblxuICAgIGZ1bmN0aW9uIHJlbW90ZVBhdGgobm9kZSkge1xuICAgICAgcmV0dXJuIHJlc29sdmUucmVsYXRpdmUobm9kZS5zb3VyY2UudmFsdWUsIHBhdGgsIGNvbnRleHQuc2V0dGluZ3MpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzb2x2ZUltcG9ydChub2RlKSB7XG4gICAgICBjb25zdCBycCA9IHJlbW90ZVBhdGgobm9kZSlcbiAgICAgIGlmIChycCA9PSBudWxsKSByZXR1cm4gbnVsbFxuICAgICAgcmV0dXJuIEV4cG9ydE1hcC5mb3IocnAsIGNvbnRleHQpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0TmFtZXNwYWNlKGlkZW50aWZpZXIpIHtcbiAgICAgIGlmICghbmFtZXNwYWNlcy5oYXMoaWRlbnRpZmllci5uYW1lKSkgcmV0dXJuXG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlSW1wb3J0KG5hbWVzcGFjZXMuZ2V0KGlkZW50aWZpZXIubmFtZSkpXG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkTmFtZXNwYWNlKG9iamVjdCwgaWRlbnRpZmllcikge1xuICAgICAgY29uc3QgbnNmbiA9IGdldE5hbWVzcGFjZShpZGVudGlmaWVyKVxuICAgICAgaWYgKG5zZm4pIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgJ25hbWVzcGFjZScsIHsgZ2V0OiBuc2ZuIH0pXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmplY3RcbiAgICB9XG5cblxuICAgIGFzdC5ib2R5LmZvckVhY2goZnVuY3Rpb24gKG4pIHtcblxuICAgICAgaWYgKG4udHlwZSA9PT0gJ0V4cG9ydERlZmF1bHREZWNsYXJhdGlvbicpIHtcbiAgICAgICAgY29uc3QgZXhwb3J0TWV0YSA9IGNhcHR1cmVEb2MoZG9jU3R5bGVQYXJzZXJzLCBuKVxuICAgICAgICBpZiAobi5kZWNsYXJhdGlvbi50eXBlID09PSAnSWRlbnRpZmllcicpIHtcbiAgICAgICAgICBhZGROYW1lc3BhY2UoZXhwb3J0TWV0YSwgbi5kZWNsYXJhdGlvbilcbiAgICAgICAgfVxuICAgICAgICBtLm5hbWVzcGFjZS5zZXQoJ2RlZmF1bHQnLCBleHBvcnRNZXRhKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgaWYgKG4udHlwZSA9PT0gJ0V4cG9ydEFsbERlY2xhcmF0aW9uJykge1xuICAgICAgICBsZXQgcmVtb3RlTWFwID0gcmVtb3RlUGF0aChuKVxuICAgICAgICBpZiAocmVtb3RlTWFwID09IG51bGwpIHJldHVyblxuICAgICAgICBtLmRlcGVuZGVuY2llcy5zZXQocmVtb3RlTWFwLCAoKSA9PiBFeHBvcnRNYXAuZm9yKHJlbW90ZU1hcCwgY29udGV4dCkpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyBjYXB0dXJlIG5hbWVzcGFjZXMgaW4gY2FzZSBvZiBsYXRlciBleHBvcnRcbiAgICAgIGlmIChuLnR5cGUgPT09ICdJbXBvcnREZWNsYXJhdGlvbicpIHtcbiAgICAgICAgbGV0IG5zXG4gICAgICAgIGlmIChuLnNwZWNpZmllcnMuc29tZShzID0+IHMudHlwZSA9PT0gJ0ltcG9ydE5hbWVzcGFjZVNwZWNpZmllcicgJiYgKG5zID0gcykpKSB7XG4gICAgICAgICAgbmFtZXNwYWNlcy5zZXQobnMubG9jYWwubmFtZSwgbilcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgaWYgKG4udHlwZSA9PT0gJ0V4cG9ydE5hbWVkRGVjbGFyYXRpb24nKXtcbiAgICAgICAgLy8gY2FwdHVyZSBkZWNsYXJhdGlvblxuICAgICAgICBpZiAobi5kZWNsYXJhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgc3dpdGNoIChuLmRlY2xhcmF0aW9uLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ0Z1bmN0aW9uRGVjbGFyYXRpb24nOlxuICAgICAgICAgICAgY2FzZSAnQ2xhc3NEZWNsYXJhdGlvbic6XG4gICAgICAgICAgICBjYXNlICdUeXBlQWxpYXMnOiAvLyBmbG93dHlwZSB3aXRoIGJhYmVsLWVzbGludCBwYXJzZXJcbiAgICAgICAgICAgICAgbS5uYW1lc3BhY2Uuc2V0KG4uZGVjbGFyYXRpb24uaWQubmFtZSwgY2FwdHVyZURvYyhkb2NTdHlsZVBhcnNlcnMsIG4pKVxuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgY2FzZSAnVmFyaWFibGVEZWNsYXJhdGlvbic6XG4gICAgICAgICAgICAgIG4uZGVjbGFyYXRpb24uZGVjbGFyYXRpb25zLmZvckVhY2goKGQpID0+XG4gICAgICAgICAgICAgICAgcmVjdXJzaXZlUGF0dGVybkNhcHR1cmUoZC5pZCwgaWQgPT5cbiAgICAgICAgICAgICAgICAgIG0ubmFtZXNwYWNlLnNldChpZC5uYW1lLCBjYXB0dXJlRG9jKGRvY1N0eWxlUGFyc2VycywgZCwgbikpKSlcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBuLnNwZWNpZmllcnMuZm9yRWFjaCgocykgPT4ge1xuICAgICAgICAgIGNvbnN0IGV4cG9ydE1ldGEgPSB7fVxuICAgICAgICAgIGxldCBsb2NhbFxuXG4gICAgICAgICAgc3dpdGNoIChzLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ0V4cG9ydERlZmF1bHRTcGVjaWZpZXInOlxuICAgICAgICAgICAgICBpZiAoIW4uc291cmNlKSByZXR1cm5cbiAgICAgICAgICAgICAgbG9jYWwgPSAnZGVmYXVsdCdcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGNhc2UgJ0V4cG9ydE5hbWVzcGFjZVNwZWNpZmllcic6XG4gICAgICAgICAgICAgIG0ubmFtZXNwYWNlLnNldChzLmV4cG9ydGVkLm5hbWUsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRNZXRhLCAnbmFtZXNwYWNlJywge1xuICAgICAgICAgICAgICAgIGdldCgpIHsgcmV0dXJuIHJlc29sdmVJbXBvcnQobikgfSxcbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgY2FzZSAnRXhwb3J0U3BlY2lmaWVyJzpcbiAgICAgICAgICAgICAgaWYgKCFuLnNvdXJjZSkge1xuICAgICAgICAgICAgICAgIG0ubmFtZXNwYWNlLnNldChzLmV4cG9ydGVkLm5hbWUsIGFkZE5hbWVzcGFjZShleHBvcnRNZXRhLCBzLmxvY2FsKSlcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBlbHNlIGZhbGxzIHRocm91Z2hcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGxvY2FsID0gcy5sb2NhbC5uYW1lXG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gdG9kbzogSlNEb2NcbiAgICAgICAgICBtLnJlZXhwb3J0cy5zZXQocy5leHBvcnRlZC5uYW1lLCB7IGxvY2FsLCBnZXRJbXBvcnQ6ICgpID0+IHJlc29sdmVJbXBvcnQobikgfSlcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgcmV0dXJuIG1cbiAgfVxuXG4gIC8qKlxuICAgKiBOb3RlIHRoYXQgdGhpcyBkb2VzIG5vdCBjaGVjayBleHBsaWNpdGx5IHJlLWV4cG9ydGVkIG5hbWVzIGZvciBleGlzdGVuY2VcbiAgICogaW4gdGhlIGJhc2UgbmFtZXNwYWNlLCBidXQgaXQgd2lsbCBleHBhbmQgYWxsIGBleHBvcnQgKiBmcm9tICcuLi4nYCBleHBvcnRzXG4gICAqIGlmIG5vdCBmb3VuZCBpbiB0aGUgZXhwbGljaXQgbmFtZXNwYWNlLlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICBuYW1lXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgYG5hbWVgIGlzIGV4cG9ydGVkIGJ5IHRoaXMgbW9kdWxlLlxuICAgKi9cbiAgaGFzKG5hbWUpIHtcbiAgICBpZiAodGhpcy5uYW1lc3BhY2UuaGFzKG5hbWUpKSByZXR1cm4gdHJ1ZVxuICAgIGlmICh0aGlzLnJlZXhwb3J0cy5oYXMobmFtZSkpIHJldHVybiB0cnVlXG5cbiAgICAvLyBkZWZhdWx0IGV4cG9ydHMgbXVzdCBiZSBleHBsaWNpdGx5IHJlLWV4cG9ydGVkICgjMzI4KVxuICAgIGlmIChuYW1lICE9PSAnZGVmYXVsdCcpIHtcbiAgICAgIGZvciAobGV0IGRlcCBvZiB0aGlzLmRlcGVuZGVuY2llcy52YWx1ZXMoKSkge1xuICAgICAgICBsZXQgaW5uZXJNYXAgPSBkZXAoKVxuXG4gICAgICAgIC8vIHRvZG86IHJlcG9ydCBhcyB1bnJlc29sdmVkP1xuICAgICAgICBpZiAoIWlubmVyTWFwKSBjb250aW51ZVxuXG4gICAgICAgIGlmIChpbm5lck1hcC5oYXMobmFtZSkpIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogZW5zdXJlIHRoYXQgaW1wb3J0ZWQgbmFtZSBmdWxseSByZXNvbHZlcy5cbiAgICogQHBhcmFtICB7W3R5cGVdfSAgbmFtZSBbZGVzY3JpcHRpb25dXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgaGFzRGVlcChuYW1lKSB7XG4gICAgaWYgKHRoaXMubmFtZXNwYWNlLmhhcyhuYW1lKSkgcmV0dXJuIHsgZm91bmQ6IHRydWUsIHBhdGg6IFt0aGlzXSB9XG5cbiAgICBpZiAodGhpcy5yZWV4cG9ydHMuaGFzKG5hbWUpKSB7XG4gICAgICBjb25zdCB7IGxvY2FsLCBnZXRJbXBvcnQgfSA9IHRoaXMucmVleHBvcnRzLmdldChuYW1lKVxuICAgICAgICAgICwgaW1wb3J0ZWQgPSBnZXRJbXBvcnQoKVxuXG4gICAgICAvLyBpZiBpbXBvcnQgaXMgaWdub3JlZCwgcmV0dXJuIGV4cGxpY2l0ICdudWxsJ1xuICAgICAgaWYgKGltcG9ydGVkID09IG51bGwpIHJldHVybiB7IGZvdW5kOiB0cnVlLCBwYXRoOiBbdGhpc10gfVxuXG4gICAgICAvLyBzYWZlZ3VhcmQgYWdhaW5zdCBjeWNsZXMsIG9ubHkgaWYgbmFtZSBtYXRjaGVzXG4gICAgICBpZiAoaW1wb3J0ZWQucGF0aCA9PT0gdGhpcy5wYXRoICYmIGxvY2FsID09PSBuYW1lKSByZXR1cm4geyBmb3VuZDogZmFsc2UsIHBhdGg6IFt0aGlzXSB9XG5cbiAgICAgIGNvbnN0IGRlZXAgPSBpbXBvcnRlZC5oYXNEZWVwKGxvY2FsKVxuICAgICAgZGVlcC5wYXRoLnVuc2hpZnQodGhpcylcblxuICAgICAgcmV0dXJuIGRlZXBcbiAgICB9XG5cblxuICAgIC8vIGRlZmF1bHQgZXhwb3J0cyBtdXN0IGJlIGV4cGxpY2l0bHkgcmUtZXhwb3J0ZWQgKCMzMjgpXG4gICAgaWYgKG5hbWUgIT09ICdkZWZhdWx0Jykge1xuICAgICAgZm9yIChsZXQgZGVwIG9mIHRoaXMuZGVwZW5kZW5jaWVzLnZhbHVlcygpKSB7XG4gICAgICAgIGxldCBpbm5lck1hcCA9IGRlcCgpXG4gICAgICAgIC8vIHRvZG86IHJlcG9ydCBhcyB1bnJlc29sdmVkP1xuICAgICAgICBpZiAoIWlubmVyTWFwKSBjb250aW51ZVxuXG4gICAgICAgIC8vIHNhZmVndWFyZCBhZ2FpbnN0IGN5Y2xlc1xuICAgICAgICBpZiAoaW5uZXJNYXAucGF0aCA9PT0gdGhpcy5wYXRoKSBjb250aW51ZVxuXG4gICAgICAgIGxldCBpbm5lclZhbHVlID0gaW5uZXJNYXAuaGFzRGVlcChuYW1lKVxuICAgICAgICBpZiAoaW5uZXJWYWx1ZS5mb3VuZCkge1xuICAgICAgICAgIGlubmVyVmFsdWUucGF0aC51bnNoaWZ0KHRoaXMpXG4gICAgICAgICAgcmV0dXJuIGlubmVyVmFsdWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7IGZvdW5kOiBmYWxzZSwgcGF0aDogW3RoaXNdIH1cbiAgfVxuXG4gIGdldChuYW1lKSB7XG4gICAgaWYgKHRoaXMubmFtZXNwYWNlLmhhcyhuYW1lKSkgcmV0dXJuIHRoaXMubmFtZXNwYWNlLmdldChuYW1lKVxuXG4gICAgaWYgKHRoaXMucmVleHBvcnRzLmhhcyhuYW1lKSkge1xuICAgICAgY29uc3QgeyBsb2NhbCwgZ2V0SW1wb3J0IH0gPSB0aGlzLnJlZXhwb3J0cy5nZXQobmFtZSlcbiAgICAgICAgICAsIGltcG9ydGVkID0gZ2V0SW1wb3J0KClcblxuICAgICAgLy8gaWYgaW1wb3J0IGlzIGlnbm9yZWQsIHJldHVybiBleHBsaWNpdCAnbnVsbCdcbiAgICAgIGlmIChpbXBvcnRlZCA9PSBudWxsKSByZXR1cm4gbnVsbFxuXG4gICAgICAvLyBzYWZlZ3VhcmQgYWdhaW5zdCBjeWNsZXMsIG9ubHkgaWYgbmFtZSBtYXRjaGVzXG4gICAgICBpZiAoaW1wb3J0ZWQucGF0aCA9PT0gdGhpcy5wYXRoICYmIGxvY2FsID09PSBuYW1lKSByZXR1cm4gdW5kZWZpbmVkXG5cbiAgICAgIHJldHVybiBpbXBvcnRlZC5nZXQobG9jYWwpXG4gICAgfVxuXG4gICAgLy8gZGVmYXVsdCBleHBvcnRzIG11c3QgYmUgZXhwbGljaXRseSByZS1leHBvcnRlZCAoIzMyOClcbiAgICBpZiAobmFtZSAhPT0gJ2RlZmF1bHQnKSB7XG4gICAgICBmb3IgKGxldCBkZXAgb2YgdGhpcy5kZXBlbmRlbmNpZXMudmFsdWVzKCkpIHtcbiAgICAgICAgbGV0IGlubmVyTWFwID0gZGVwKClcbiAgICAgICAgLy8gdG9kbzogcmVwb3J0IGFzIHVucmVzb2x2ZWQ/XG4gICAgICAgIGlmICghaW5uZXJNYXApIGNvbnRpbnVlXG5cbiAgICAgICAgLy8gc2FmZWd1YXJkIGFnYWluc3QgY3ljbGVzXG4gICAgICAgIGlmIChpbm5lck1hcC5wYXRoID09PSB0aGlzLnBhdGgpIGNvbnRpbnVlXG5cbiAgICAgICAgbGV0IGlubmVyVmFsdWUgPSBpbm5lck1hcC5nZXQobmFtZSlcbiAgICAgICAgaWYgKGlubmVyVmFsdWUgIT09IHVuZGVmaW5lZCkgcmV0dXJuIGlubmVyVmFsdWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICBmb3JFYWNoKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgdGhpcy5uYW1lc3BhY2UuZm9yRWFjaCgodiwgbikgPT5cbiAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgdiwgbiwgdGhpcykpXG5cbiAgICB0aGlzLnJlZXhwb3J0cy5mb3JFYWNoKCh7IGdldEltcG9ydCwgbG9jYWwgfSwgbmFtZSkgPT4ge1xuICAgICAgY29uc3QgcmVleHBvcnRlZCA9IGdldEltcG9ydCgpXG4gICAgICAvLyBjYW4ndCBsb29rIHVwIG1ldGEgZm9yIGlnbm9yZWQgcmUtZXhwb3J0cyAoIzM0OClcbiAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgcmVleHBvcnRlZCAmJiByZWV4cG9ydGVkLmdldChsb2NhbCksIG5hbWUsIHRoaXMpXG4gICAgfSlcblxuICAgIHRoaXMuZGVwZW5kZW5jaWVzLmZvckVhY2goZGVwID0+IGRlcCgpLmZvckVhY2goKHYsIG4pID0+XG4gICAgICBuICE9PSAnZGVmYXVsdCcgJiYgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB2LCBuLCB0aGlzKSkpXG4gIH1cblxuICAvLyB0b2RvOiBrZXlzLCB2YWx1ZXMsIGVudHJpZXM/XG5cbiAgcmVwb3J0RXJyb3JzKGNvbnRleHQsIGRlY2xhcmF0aW9uKSB7XG4gICAgY29udGV4dC5yZXBvcnQoe1xuICAgICAgbm9kZTogZGVjbGFyYXRpb24uc291cmNlLFxuICAgICAgbWVzc2FnZTogYFBhcnNlIGVycm9ycyBpbiBpbXBvcnRlZCBtb2R1bGUgJyR7ZGVjbGFyYXRpb24uc291cmNlLnZhbHVlfSc6IGAgK1xuICAgICAgICAgICAgICAgICAgYCR7dGhpcy5lcnJvcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZSA9PiBgJHtlLm1lc3NhZ2V9ICgke2UubGluZU51bWJlcn06JHtlLmNvbHVtbn0pYClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKCcsICcpfWAsXG4gICAgfSlcbiAgfVxufVxuXG4vKipcbiAqIHBhcnNlIGRvY3MgZnJvbSB0aGUgZmlyc3Qgbm9kZSB0aGF0IGhhcyBsZWFkaW5nIGNvbW1lbnRzXG4gKiBAcGFyYW0gIHsuLi5bdHlwZV19IG5vZGVzIFtkZXNjcmlwdGlvbl1cbiAqIEByZXR1cm4ge3tkb2M6IG9iamVjdH19XG4gKi9cbmZ1bmN0aW9uIGNhcHR1cmVEb2MoZG9jU3R5bGVQYXJzZXJzLCAuLi5ub2Rlcykge1xuICBjb25zdCBtZXRhZGF0YSA9IHt9XG5cbiAgLy8gJ3NvbWUnIHNob3J0LWNpcmN1aXRzIG9uIGZpcnN0ICd0cnVlJ1xuICBub2Rlcy5zb21lKG4gPT4ge1xuICAgIGlmICghbi5sZWFkaW5nQ29tbWVudHMpIHJldHVybiBmYWxzZVxuXG4gICAgZm9yIChsZXQgbmFtZSBpbiBkb2NTdHlsZVBhcnNlcnMpIHtcbiAgICAgIGNvbnN0IGRvYyA9IGRvY1N0eWxlUGFyc2Vyc1tuYW1lXShuLmxlYWRpbmdDb21tZW50cylcbiAgICAgIGlmIChkb2MpIHtcbiAgICAgICAgbWV0YWRhdGEuZG9jID0gZG9jXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfSlcblxuICByZXR1cm4gbWV0YWRhdGFcbn1cblxuY29uc3QgYXZhaWxhYmxlRG9jU3R5bGVQYXJzZXJzID0ge1xuICBqc2RvYzogY2FwdHVyZUpzRG9jLFxuICB0b21kb2M6IGNhcHR1cmVUb21Eb2MsXG59XG5cbi8qKlxuICogcGFyc2UgSlNEb2MgZnJvbSBsZWFkaW5nIGNvbW1lbnRzXG4gKiBAcGFyYW0gIHsuLi5bdHlwZV19IGNvbW1lbnRzIFtkZXNjcmlwdGlvbl1cbiAqIEByZXR1cm4ge3tkb2M6IG9iamVjdH19XG4gKi9cbmZ1bmN0aW9uIGNhcHR1cmVKc0RvYyhjb21tZW50cykge1xuICBsZXQgZG9jXG5cbiAgLy8gY2FwdHVyZSBYU0RvY1xuICBjb21tZW50cy5mb3JFYWNoKGNvbW1lbnQgPT4ge1xuICAgIC8vIHNraXAgbm9uLWJsb2NrIGNvbW1lbnRzXG4gICAgaWYgKGNvbW1lbnQudmFsdWUuc2xpY2UoMCwgNCkgIT09ICcqXFxuIConKSByZXR1cm5cbiAgICB0cnkge1xuICAgICAgZG9jID0gZG9jdHJpbmUucGFyc2UoY29tbWVudC52YWx1ZSwgeyB1bndyYXA6IHRydWUgfSlcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8qIGRvbid0IGNhcmUsIGZvciBub3c/IG1heWJlIGFkZCB0byBgZXJyb3JzP2AgKi9cbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIGRvY1xufVxuXG4vKipcbiAgKiBwYXJzZSBUb21Eb2Mgc2VjdGlvbiBmcm9tIGNvbW1lbnRzXG4gICovXG5mdW5jdGlvbiBjYXB0dXJlVG9tRG9jKGNvbW1lbnRzKSB7XG4gIC8vIGNvbGxlY3QgbGluZXMgdXAgdG8gZmlyc3QgcGFyYWdyYXBoIGJyZWFrXG4gIGNvbnN0IGxpbmVzID0gW11cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb21tZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNvbW1lbnQgPSBjb21tZW50c1tpXVxuICAgIGlmIChjb21tZW50LnZhbHVlLm1hdGNoKC9eXFxzKiQvKSkgYnJlYWtcbiAgICBsaW5lcy5wdXNoKGNvbW1lbnQudmFsdWUudHJpbSgpKVxuICB9XG5cbiAgLy8gcmV0dXJuIGRvY3RyaW5lLWxpa2Ugb2JqZWN0XG4gIGNvbnN0IHN0YXR1c01hdGNoID0gbGluZXMuam9pbignICcpLm1hdGNoKC9eKFB1YmxpY3xJbnRlcm5hbHxEZXByZWNhdGVkKTpcXHMqKC4rKS8pXG4gIGlmIChzdGF0dXNNYXRjaCkge1xuICAgIHJldHVybiB7XG4gICAgICBkZXNjcmlwdGlvbjogc3RhdHVzTWF0Y2hbMl0sXG4gICAgICB0YWdzOiBbe1xuICAgICAgICB0aXRsZTogc3RhdHVzTWF0Y2hbMV0udG9Mb3dlckNhc2UoKSxcbiAgICAgICAgZGVzY3JpcHRpb246IHN0YXR1c01hdGNoWzJdLFxuICAgICAgfV0sXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVHJhdmVyc2UgYSBwYXR0ZXJuL2lkZW50aWZpZXIgbm9kZSwgY2FsbGluZyAnY2FsbGJhY2snXG4gKiBmb3IgZWFjaCBsZWFmIGlkZW50aWZpZXIuXG4gKiBAcGFyYW0gIHtub2RlfSAgIHBhdHRlcm5cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybiB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlY3Vyc2l2ZVBhdHRlcm5DYXB0dXJlKHBhdHRlcm4sIGNhbGxiYWNrKSB7XG4gIHN3aXRjaCAocGF0dGVybi50eXBlKSB7XG4gICAgY2FzZSAnSWRlbnRpZmllcic6IC8vIGJhc2UgY2FzZVxuICAgICAgY2FsbGJhY2socGF0dGVybilcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlICdPYmplY3RQYXR0ZXJuJzpcbiAgICAgIHBhdHRlcm4ucHJvcGVydGllcy5mb3JFYWNoKCh7IHZhbHVlIH0pID0+IHtcbiAgICAgICAgcmVjdXJzaXZlUGF0dGVybkNhcHR1cmUodmFsdWUsIGNhbGxiYWNrKVxuICAgICAgfSlcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlICdBcnJheVBhdHRlcm4nOlxuICAgICAgcGF0dGVybi5lbGVtZW50cy5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgICAgIGlmIChlbGVtZW50ID09IG51bGwpIHJldHVyblxuICAgICAgICByZWN1cnNpdmVQYXR0ZXJuQ2FwdHVyZShlbGVtZW50LCBjYWxsYmFjaylcbiAgICAgIH0pXG4gICAgICBicmVha1xuICB9XG59XG4iXX0=