'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _lodash = require('lodash.endswith');

var _lodash2 = _interopRequireDefault(_lodash);

var _resolve = require('../core/resolve');

var _resolve2 = _interopRequireDefault(_resolve);

var _importType = require('../core/importType');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = function (context) {
  var configuration = context.options[0] || 'never';

  function isUseOfExtensionEnforced(extension) {
    if ((typeof configuration === 'undefined' ? 'undefined' : _typeof(configuration)) === 'object') {
      return configuration[extension] === 'always';
    }

    return configuration === 'always';
  }

  function isResolvableWithoutExtension(file) {
    var extension = _path2.default.extname(file);
    var fileWithoutExtension = file.slice(0, -extension.length);
    var resolvedFileWithoutExtension = (0, _resolve2.default)(fileWithoutExtension, context);

    return resolvedFileWithoutExtension === (0, _resolve2.default)(file, context);
  }

  function checkFileExtension(node) {
    var source = node.source;

    var importPath = source.value;

    // don't enforce anything on builtins
    if ((0, _importType.isBuiltIn)(importPath, context.settings)) return;

    var resolvedPath = (0, _resolve2.default)(importPath, context);

    // get extension from resolved path, if possible.
    // for unresolved, use source value.
    var extension = _path2.default.extname(resolvedPath || importPath).substring(1);

    if (!extension || !(0, _lodash2.default)(importPath, extension)) {
      if (isUseOfExtensionEnforced(extension)) {
        context.report({
          node: source,
          message: 'Missing file extension ' + (extension ? '"' + extension + '" ' : '') + 'for "' + importPath + '"'
        });
      }
    } else if (extension) {
      if (!isUseOfExtensionEnforced(extension) && isResolvableWithoutExtension(importPath)) {
        context.report({
          node: source,
          message: 'Unexpected use of file extension "' + extension + '" for "' + importPath + '"'
        });
      }
    }
  }

  return {
    ImportDeclaration: checkFileExtension
  };
};

module.exports.schema = [{
  oneOf: [{
    enum: ['always', 'never']
  }, {
    type: 'object',
    patternProperties: {
      '.*': { enum: ['always', 'never'] }
    }
  }]
}];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInJ1bGVzL2V4dGVuc2lvbnMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBOzs7O0FBQ0E7Ozs7QUFFQTs7OztBQUNBOzs7O0FBRUEsT0FBTyxPQUFQLEdBQWlCLFVBQVUsT0FBVixFQUFtQjtBQUNsQyxNQUFNLGdCQUFnQixRQUFRLE9BQVIsQ0FBZ0IsQ0FBaEIsS0FBc0IsT0FBdEIsQ0FEWTs7QUFHbEMsV0FBUyx3QkFBVCxDQUFrQyxTQUFsQyxFQUE2QztBQUMzQyxRQUFJLFFBQU8scUVBQVAsS0FBeUIsUUFBekIsRUFBbUM7QUFDckMsYUFBTyxjQUFjLFNBQWQsTUFBNkIsUUFBN0IsQ0FEOEI7S0FBdkM7O0FBSUEsV0FBTyxrQkFBa0IsUUFBbEIsQ0FMb0M7R0FBN0M7O0FBUUEsV0FBUyw0QkFBVCxDQUFzQyxJQUF0QyxFQUE0QztBQUMxQyxRQUFNLFlBQVksZUFBSyxPQUFMLENBQWEsSUFBYixDQUFaLENBRG9DO0FBRTFDLFFBQU0sdUJBQXVCLEtBQUssS0FBTCxDQUFXLENBQVgsRUFBYyxDQUFDLFVBQVUsTUFBVixDQUF0QyxDQUZvQztBQUcxQyxRQUFNLCtCQUErQix1QkFBUSxvQkFBUixFQUE4QixPQUE5QixDQUEvQixDQUhvQzs7QUFLMUMsV0FBTyxpQ0FBaUMsdUJBQVEsSUFBUixFQUFjLE9BQWQsQ0FBakMsQ0FMbUM7R0FBNUM7O0FBUUEsV0FBUyxrQkFBVCxDQUE0QixJQUE1QixFQUFrQztRQUN4QixTQUFXLEtBQVgsT0FEd0I7O0FBRWhDLFFBQU0sYUFBYSxPQUFPLEtBQVA7OztBQUZhLFFBSzVCLDJCQUFVLFVBQVYsRUFBc0IsUUFBUSxRQUFSLENBQTFCLEVBQTZDLE9BQTdDOztBQUVBLFFBQU0sZUFBZSx1QkFBUSxVQUFSLEVBQW9CLE9BQXBCLENBQWY7Ozs7QUFQMEIsUUFXMUIsWUFBWSxlQUFLLE9BQUwsQ0FBYSxnQkFBZ0IsVUFBaEIsQ0FBYixDQUF5QyxTQUF6QyxDQUFtRCxDQUFuRCxDQUFaLENBWDBCOztBQWFoQyxRQUFJLENBQUMsU0FBRCxJQUFjLENBQUMsc0JBQVMsVUFBVCxFQUFxQixTQUFyQixDQUFELEVBQWtDO0FBQ2xELFVBQUkseUJBQXlCLFNBQXpCLENBQUosRUFBeUM7QUFDdkMsZ0JBQVEsTUFBUixDQUFlO0FBQ2IsZ0JBQU0sTUFBTjtBQUNBLGdEQUM0QixrQkFBZ0IsZ0JBQWhCLEdBQWdDLEVBQWhDLGNBQTBDLGdCQUR0RTtTQUZGLEVBRHVDO09BQXpDO0tBREYsTUFRTyxJQUFJLFNBQUosRUFBZTtBQUNwQixVQUFJLENBQUMseUJBQXlCLFNBQXpCLENBQUQsSUFBd0MsNkJBQTZCLFVBQTdCLENBQXhDLEVBQWtGO0FBQ3BGLGdCQUFRLE1BQVIsQ0FBZTtBQUNiLGdCQUFNLE1BQU47QUFDQSwwREFBOEMsd0JBQW1CLGdCQUFqRTtTQUZGLEVBRG9GO09BQXRGO0tBREs7R0FyQlQ7O0FBK0JBLFNBQU87QUFDTCx1QkFBbUIsa0JBQW5CO0dBREYsQ0FsRGtDO0NBQW5COztBQXVEakIsT0FBTyxPQUFQLENBQWUsTUFBZixHQUF3QixDQUN0QjtBQUNFLFNBQU8sQ0FDTDtBQUNFLFVBQU0sQ0FBRSxRQUFGLEVBQVksT0FBWixDQUFOO0dBRkcsRUFJTDtBQUNFLFVBQU0sUUFBTjtBQUNBLHVCQUFtQjtBQUNqQixZQUFNLEVBQUUsTUFBTSxDQUFFLFFBQUYsRUFBWSxPQUFaLENBQU4sRUFBUjtLQURGO0dBTkcsQ0FBUDtDQUZvQixDQUF4QiIsImZpbGUiOiJydWxlcy9leHRlbnNpb25zLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHBhdGggZnJvbSAncGF0aCdcbmltcG9ydCBlbmRzV2l0aCBmcm9tICdsb2Rhc2guZW5kc3dpdGgnXG5cbmltcG9ydCByZXNvbHZlIGZyb20gJy4uL2NvcmUvcmVzb2x2ZSdcbmltcG9ydCB7IGlzQnVpbHRJbiB9IGZyb20gJy4uL2NvcmUvaW1wb3J0VHlwZSdcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICBjb25zdCBjb25maWd1cmF0aW9uID0gY29udGV4dC5vcHRpb25zWzBdIHx8ICduZXZlcidcblxuICBmdW5jdGlvbiBpc1VzZU9mRXh0ZW5zaW9uRW5mb3JjZWQoZXh0ZW5zaW9uKSB7XG4gICAgaWYgKHR5cGVvZiBjb25maWd1cmF0aW9uID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIGNvbmZpZ3VyYXRpb25bZXh0ZW5zaW9uXSA9PT0gJ2Fsd2F5cydcbiAgICB9XG5cbiAgICByZXR1cm4gY29uZmlndXJhdGlvbiA9PT0gJ2Fsd2F5cydcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUmVzb2x2YWJsZVdpdGhvdXRFeHRlbnNpb24oZmlsZSkge1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IHBhdGguZXh0bmFtZShmaWxlKVxuICAgIGNvbnN0IGZpbGVXaXRob3V0RXh0ZW5zaW9uID0gZmlsZS5zbGljZSgwLCAtZXh0ZW5zaW9uLmxlbmd0aClcbiAgICBjb25zdCByZXNvbHZlZEZpbGVXaXRob3V0RXh0ZW5zaW9uID0gcmVzb2x2ZShmaWxlV2l0aG91dEV4dGVuc2lvbiwgY29udGV4dClcblxuICAgIHJldHVybiByZXNvbHZlZEZpbGVXaXRob3V0RXh0ZW5zaW9uID09PSByZXNvbHZlKGZpbGUsIGNvbnRleHQpXG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0ZpbGVFeHRlbnNpb24obm9kZSkge1xuICAgIGNvbnN0IHsgc291cmNlIH0gPSBub2RlXG4gICAgY29uc3QgaW1wb3J0UGF0aCA9IHNvdXJjZS52YWx1ZVxuXG4gICAgLy8gZG9uJ3QgZW5mb3JjZSBhbnl0aGluZyBvbiBidWlsdGluc1xuICAgIGlmIChpc0J1aWx0SW4oaW1wb3J0UGF0aCwgY29udGV4dC5zZXR0aW5ncykpIHJldHVyblxuXG4gICAgY29uc3QgcmVzb2x2ZWRQYXRoID0gcmVzb2x2ZShpbXBvcnRQYXRoLCBjb250ZXh0KVxuXG4gICAgLy8gZ2V0IGV4dGVuc2lvbiBmcm9tIHJlc29sdmVkIHBhdGgsIGlmIHBvc3NpYmxlLlxuICAgIC8vIGZvciB1bnJlc29sdmVkLCB1c2Ugc291cmNlIHZhbHVlLlxuICAgIGNvbnN0IGV4dGVuc2lvbiA9IHBhdGguZXh0bmFtZShyZXNvbHZlZFBhdGggfHwgaW1wb3J0UGF0aCkuc3Vic3RyaW5nKDEpXG5cbiAgICBpZiAoIWV4dGVuc2lvbiB8fCAhZW5kc1dpdGgoaW1wb3J0UGF0aCwgZXh0ZW5zaW9uKSkge1xuICAgICAgaWYgKGlzVXNlT2ZFeHRlbnNpb25FbmZvcmNlZChleHRlbnNpb24pKSB7XG4gICAgICAgIGNvbnRleHQucmVwb3J0KHtcbiAgICAgICAgICBub2RlOiBzb3VyY2UsXG4gICAgICAgICAgbWVzc2FnZTpcbiAgICAgICAgICAgIGBNaXNzaW5nIGZpbGUgZXh0ZW5zaW9uICR7ZXh0ZW5zaW9uID8gYFwiJHtleHRlbnNpb259XCIgYCA6ICcnfWZvciBcIiR7aW1wb3J0UGF0aH1cImAsXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChleHRlbnNpb24pIHtcbiAgICAgIGlmICghaXNVc2VPZkV4dGVuc2lvbkVuZm9yY2VkKGV4dGVuc2lvbikgJiYgaXNSZXNvbHZhYmxlV2l0aG91dEV4dGVuc2lvbihpbXBvcnRQYXRoKSkge1xuICAgICAgICBjb250ZXh0LnJlcG9ydCh7XG4gICAgICAgICAgbm9kZTogc291cmNlLFxuICAgICAgICAgIG1lc3NhZ2U6IGBVbmV4cGVjdGVkIHVzZSBvZiBmaWxlIGV4dGVuc2lvbiBcIiR7ZXh0ZW5zaW9ufVwiIGZvciBcIiR7aW1wb3J0UGF0aH1cImAsXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBJbXBvcnREZWNsYXJhdGlvbjogY2hlY2tGaWxlRXh0ZW5zaW9uLFxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzLnNjaGVtYSA9IFtcbiAge1xuICAgIG9uZU9mOiBbXG4gICAgICB7XG4gICAgICAgIGVudW06IFsgJ2Fsd2F5cycsICduZXZlcicgXSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICBwYXR0ZXJuUHJvcGVydGllczoge1xuICAgICAgICAgICcuKic6IHsgZW51bTogWyAnYWx3YXlzJywgJ25ldmVyJyBdIH0sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIF0sXG4gIH0sXG5dXG4iXX0=